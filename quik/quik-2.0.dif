diff -ru quik-2.0/Makefile quik-2.0.modified/Makefile
--- quik-2.0/Makefile	Fri Mar 10 21:59:28 2000
+++ quik-2.0.modified/Makefile	Wed Apr 26 11:14:35 2000
@@ -9,11 +9,11 @@
 	install -d -m 755 $(DESTDIR)/sbin
 	install -d -m 755 $(DESTDIR)/boot
 	install -d -m 755 $(DESTDIR)/etc
-	install -d -m 755 $(DESTDIR)/usr/man/man5
-	install -d -m 755 $(DESTDIR)/usr/man/man8
+	install -d -m 755 $(DESTDIR)/usr/share/man/man5
+	install -d -m 755 $(DESTDIR)/usr/share/man/man8
 	install -s quik/quik $(DESTDIR)/sbin
 	install -m 444 first/first.b second/second.b second/second $(DESTDIR)/boot
 	if [ -f $(DESTDIR)/etc/quik.conf ]; then :; \
 	  else set -x; install -m 644 etc/quik.conf $(DESTDIR)/etc; fi
-	install -m 444 man/quik.conf.5 $(DESTDIR)/usr/man/man5
-	install -m 444 man/quik.8 man/bootstrap.8 $(DESTDIR)/usr/man/man8
+	install -m 444 man/quik.conf.5 $(DESTDIR)/usr/share/man/man5
+	install -m 444 man/quik.8 man/bootstrap.8 $(DESTDIR)/usr/share/man/man8
diff -ru quik-2.0/etc/quik.conf quik-2.0.modified/etc/quik.conf
--- quik-2.0/etc/quik.conf	Fri Mar 10 21:59:28 2000
+++ quik-2.0.modified/etc/quik.conf	Wed Apr 26 11:59:32 2000
@@ -3,5 +3,6 @@
 default = linux
 image = /boot/vmlinux
 	label = linux
+	root = /dev/sda3
 image = /boot/vmlinux.old
 	label = old
diff -ru quik-2.0/quik/quik.c quik-2.0.modified/quik/quik.c
--- quik-2.0/quik/quik.c	Fri Mar 10 21:59:28 2000
+++ quik-2.0.modified/quik/quik.c	Wed Apr 26 11:14:35 2000
@@ -547,7 +547,7 @@
 	bootdev[7] += UNIT(st1.st_dev);
     strcpy(spart, bootdev);
     if (PART(st1.st_dev) != 0)
-	sprintf(spart+8, "%d", PART(st1.st_dev));
+	sprintf(spart+8, "%d", (int)PART(st1.st_dev));
 
     if (verbose)
 	printf("Second-stage loader is on %s\n", spart);
diff -ru quik-2.0/second/file.c quik-2.0.modified/second/file.c
--- quik-2.0/second/file.c	Fri Mar 10 21:59:28 2000
+++ quik-2.0.modified/second/file.c	Wed Apr 26 11:14:35 2000
@@ -401,6 +404,7 @@
     if (*filename == '[')
 	return dump_device_range (filename, bogusdev, len, lenfunc);
     if (!open_ext2(bogusdev)) {
+	printf("%s perhaps not ext2  -  ", bogusdev);
 	fatal ("Unable to open filesystem");
 	return 0;
     }
Only in quik-2.0.modified/second: file.c.orig
diff -ru quik-2.0/second/main.c quik-2.0.modified/second/main.c
--- quik-2.0/second/main.c	Fri Mar 10 21:59:28 2000
+++ quik-2.0.modified/second/main.c	Wed Apr 26 11:51:39 2000
@@ -40,7 +40,7 @@
 #define ADDRMASK	0x0fffffff
 
 char quik_conf[40];
-int quik_conf_part;
+int quik_conf_part = 0;
 unsigned int is_chrp = 0;
 
 extern int start;
@@ -369,8 +369,9 @@
 	     * Assume root partition is partition 2.  We should
 	     * scan the disk looking for a linux FS with /etc/quik.conf.
 	     * -- Cort
+             * we did it -- uli
 	     */
-	    fip->conf_part = 2;
+	    fip->conf_part = 1;
 	    strcpy( fip->conf_file, "/etc/quik.conf" );
     }
 
@@ -398,13 +399,22 @@
     quik_conf_part = fip->conf_part;
     strncpy(quik_conf, fip->conf_file, sizeof(fip->conf_file));
     if (*quik_conf && quik_conf_part >= 0) {
-	int len;
-	fileok = load_file(0, quik_conf_part, quik_conf,
+	int len,i,success=0;
+	for (i=quik_conf_part;i<8;i++)
+	{
+		fileok = load_file(0, i, quik_conf,
 			   TMP_BUF, TMP_END, &len, 1, 0);
-	if (!fileok || (unsigned) len >= 65535)
+		if (fileok && (!((unsigned) len >= 65535))) {
+			success=1;
+			break;
+		}
+		printf("Coudln't find %s on partition %d", quik_conf, i);
+	}
+	if (!success)
 	    printf("\nCouldn't load %s\n", quik_conf);
 	else {
 	    char *p;
+	    fip->conf_part=quik_conf_part=i;
 	    if (cfg_parse(quik_conf, TMP_BUF, len) < 0)
 	        printf ("Syntax error or read error in %s.\n", quik_conf);
 	    useconf = 1;
@@ -426,7 +436,7 @@
 	if (!kname)
 	    continue;
 	
-	fileok = load_file(device, part, kname,
+	fileok = load_file(device, quik_conf_part, kname,
 			   TMP_BUF, TMP_END, &image_len, 1, 0);
 
 	if (!fileok) {
@@ -497,10 +507,22 @@
      * point may actually be a procedure descriptor.
      */
     start = *(unsigned *)entry;
-    if (start < load_loc || start >= load_loc + len
-	|| ((unsigned *)entry)[2] != 0)
-	/* doesn't look like a procedure descriptor */
-	start += entry;
+//    if (start < load_loc || start >= load_loc + len
+//	|| ((unsigned *)entry)[2] != 0)
+//	/* doesn't look like a procedure descriptor */
+//	start += entry;
+    /* new boot strategy - see head.S in the kernel for more info -- Cort */
+    if (start == 0x60000000/* nop */ )
+           start = load_loc;
+    /* not the new boot strategy, use old logic -- Cort */
+    else
+    {
+           if (start < load_loc || start >= load_loc + len
+               || ((unsigned *)entry)[2] != 0)
+                   /* doesn't look like a procedure descriptor */
+                   start += entry;
+    }
+
     printf("Starting at %x\n", start);
 #ifdef BOOTINFO    
     /* setup the bootinfo */
