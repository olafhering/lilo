--- Makefile
+++ Makefile	2000/07/19 12:43:18
@@ -9,11 +9,11 @@
 	install -d -m 755 $(DESTDIR)/sbin
 	install -d -m 755 $(DESTDIR)/boot
 	install -d -m 755 $(DESTDIR)/etc
-	install -d -m 755 $(DESTDIR)/usr/man/man5
-	install -d -m 755 $(DESTDIR)/usr/man/man8
+	install -d -m 755 $(DESTDIR)/usr/share/man/man5
+	install -d -m 755 $(DESTDIR)/usr/share/man/man8
 	install -s quik/quik $(DESTDIR)/sbin
 	install -m 444 first/first.b second/second.b second/second $(DESTDIR)/boot
 	if [ -f $(DESTDIR)/etc/quik.conf ]; then :; \
 	  else set -x; install -m 644 etc/quik.conf $(DESTDIR)/etc; fi
-	install -m 444 man/quik.conf.5 $(DESTDIR)/usr/man/man5
-	install -m 444 man/quik.8 man/bootstrap.8 $(DESTDIR)/usr/man/man8
+	install -m 444 man/quik.conf.5 $(DESTDIR)/usr/share/man/man5
+	install -m 444 man/quik.8 man/bootstrap.8 $(DESTDIR)/usr/share/man/man8
--- quik/quik.c
+++ quik/quik.c	2000/07/19 12:43:18
@@ -547,7 +547,7 @@
 	bootdev[7] += UNIT(st1.st_dev);
     strcpy(spart, bootdev);
     if (PART(st1.st_dev) != 0)
-	sprintf(spart+8, "%d", PART(st1.st_dev));
+	sprintf(spart+8, "%d", (int)PART(st1.st_dev));
 
     if (verbose)
 	printf("Second-stage loader is on %s\n", spart);
--- second/cfg.c
+++ second/cfg.c	2000/07/19 12:44:24
@@ -55,6 +55,11 @@
     {cft_strg, "pause-message", NULL},
     {cft_strg, "init-code", NULL},
     {cft_strg, "init-message", NULL},
+    {cft_strg, "other", NULL},
+    {cft_strg, "boot", NULL},
+    {cft_strg, "bootfolder", NULL},
+    {cft_strg, "activate", NULL},
+    {cft_strg, "copy", NULL},
     {cft_end, NULL, NULL}};
 
 CONFIG cf_image[] =
@@ -75,6 +80,7 @@
     {cft_strg, "initrd-size", NULL},
     {cft_flag, "pause-after", NULL},
     {cft_strg, "pause-message", NULL},
+    {cft_strg, "copy", NULL},
     {cft_end, NULL, NULL}};
 
 static char flag_set;
--- second/file.c
+++ second/file.c	2000/07/19 12:43:18
@@ -401,6 +401,7 @@
     if (*filename == '[')
 	return dump_device_range (filename, bogusdev, len, lenfunc);
     if (!open_ext2(bogusdev)) {
+	printf("\n %s perhaps not ext2  -  ", bogusdev);
 	fatal ("Unable to open filesystem");
 	return 0;
     }
--- second/main.c
+++ second/main.c	2000/07/19 12:45:15
@@ -40,7 +40,7 @@
 #define ADDRMASK	0x0fffffff
 
 char quik_conf[40];
-int quik_conf_part;
+int quik_conf_part = 0;
 unsigned int is_chrp = 0;
 
 extern int start;
@@ -369,9 +369,11 @@
 	     * Assume root partition is partition 2.  We should
 	     * scan the disk looking for a linux FS with /etc/quik.conf.
 	     * -- Cort
+             * we did it -- uli
+             * rename quik.conf to lilo.conf -- olh
 	     */
-	    fip->conf_part = 2;
-	    strcpy( fip->conf_file, "/etc/quik.conf" );
+	    fip->conf_part = 1;
+	    strcpy( fip->conf_file, "/etc/lilo.conf" );
     }
 
     if ( (unsigned long)prom_entry == 0x426f6f58 )
@@ -398,13 +400,22 @@
     quik_conf_part = fip->conf_part;
     strncpy(quik_conf, fip->conf_file, sizeof(fip->conf_file));
     if (*quik_conf && quik_conf_part >= 0) {
-	int len;
-	fileok = load_file(0, quik_conf_part, quik_conf,
+	int len,i,success=0;
+	for (i=quik_conf_part;i<8;i++)
+	{
+		fileok = load_file(0, i, quik_conf,
 			   TMP_BUF, TMP_END, &len, 1, 0);
-	if (!fileok || (unsigned) len >= 65535)
+		if (fileok && (!((unsigned) len >= 65535))) {
+			success=1;
+			break;
+		}
+		printf("Coudln't find %s on partition %d", quik_conf, i);
+	}
+	if (!success)
 	    printf("\nCouldn't load %s\n", quik_conf);
 	else {
 	    char *p;
+	    fip->conf_part=quik_conf_part=i;
 	    if (cfg_parse(quik_conf, TMP_BUF, len) < 0)
 	        printf ("Syntax error or read error in %s.\n", quik_conf);
 	    useconf = 1;
@@ -426,7 +437,7 @@
 	if (!kname)
 	    continue;
 	
-	fileok = load_file(device, part, kname,
+	fileok = load_file(device, quik_conf_part, kname,
 			   TMP_BUF, TMP_END, &image_len, 1, 0);
 
 	if (!fileok) {
@@ -497,10 +508,22 @@
      * point may actually be a procedure descriptor.
      */
     start = *(unsigned *)entry;
-    if (start < load_loc || start >= load_loc + len
-	|| ((unsigned *)entry)[2] != 0)
-	/* doesn't look like a procedure descriptor */
-	start += entry;
+//    if (start < load_loc || start >= load_loc + len
+//	|| ((unsigned *)entry)[2] != 0)
+//	/* doesn't look like a procedure descriptor */
+//	start += entry;
+    /* new boot strategy - see head.S in the kernel for more info -- Cort */
+    if (start == 0x60000000/* nop */ )
+           start = load_loc;
+    /* not the new boot strategy, use old logic -- Cort */
+    else
+    {
+           if (start < load_loc || start >= load_loc + len
+               || ((unsigned *)entry)[2] != 0)
+                   /* doesn't look like a procedure descriptor */
+                   start += entry;
+    }
+
     printf("Starting at %x\n", start);
 #ifdef BOOTINFO    
     /* setup the bootinfo */
