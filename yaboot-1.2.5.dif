--- README
+++ README	2001/11/08 13:34:43
@@ -25,3 +25,23 @@
 "OldWorld" PowerMacs (with the old MacOS ROM buit-in) are not
 supported.
 
+
+
+yaboot must be able to handle these image path names
+(use this as a testcase)
+
+HFS:
+hd:9,vmlinux
+hd:9,\vmlinux
+hd:9,\\vmlinux
+hd:9,\folder\vmlinux
+vmlinux	(look at the same place as yaboot.conf)
+
+ext2, reiserfs:
+hd:10,vmlinux
+hd:10,/vmlinux
+hd:10,/boot/vmlinux
+
+same goes for initrd and sysmap.
+
+
--- yaboot.c
+++ yaboot.c	2001/11/08 13:37:25
@@ -111,6 +111,7 @@
 char *password = NULL;
 int bootpartition = -1;
 int _machine = _MACH_Pmac;
+int booting_vmlinux = 1;
 
 #ifdef CONFIG_COLOR_TEXT
 
@@ -298,8 +299,7 @@
     fspec.dev = device;
     fspec.file = conf_path;
     fspec.part = partition;
-    result = open_file(&fspec, &file);
-    if (result != FILE_ERR_OK) {
+    if (open_file(&fspec, &file) != FILE_ERR_OK) {
     	prom_printf("Can't open config file '%s', err: %d\n", conf_path, result);
 	goto bail;
     }
@@ -666,6 +666,15 @@
 	}
     }
 
+    if (imagename == NULL) {
+	prom_printf(
+"Enter the kernel image name as [device:][partno]/path, where partno is a\n"
+"number from 0 to 16.  Instead of /path you can type [mm-nn] to specify a\n"
+"range of disk blocks (512B)\n"
+"Example: hd:3,/vmlinux\n");
+        return 0;
+    }
+
     if (!strcmp (imagename, "halt")) {
 	 if (password)
 	      check_password ("P");
@@ -813,20 +822,22 @@
 	if ( is_elf32(&loadinfo) ) {
             if ( !load_elf32(&file, &loadinfo) )
                 goto next;
-            prom_printf("   Elf32 kernel loaded...\n");
+            prom_printf("   Elf32 %s loaded...\n",
+		(booting_vmlinux) ? "kernel (vmlinux)" : "binary");
 	} else if ( is_elf64(&loadinfo) ) {
             if ( !load_elf64(&file, &loadinfo) )
                 goto next;
-            prom_printf("   Elf64 kernel loaded...\n");
+            prom_printf("   Elf64 %s loaded...\n",
+		(booting_vmlinux) ? "kernel (vmlinux)" : "binary");
 	} else {
             prom_printf ("Not a valid ELF image\n");
             goto next;
 	}
         file.fs->close(&file);
 
-	/* If sysmap, load it. 
+	/* If sysmap, load it if booting a vmlinux.
 	 */
-	if (params.sysmap.file) {
+	if (booting_vmlinux && params.sysmap.file) {
 	    prom_printf("Loading System.map ...\n");
 	    if(bootpath && !strcmp(bootpath,"\\\\") && params.sysmap.file[0] != '/') {
 		    if (loc) free(loc);
@@ -864,14 +875,12 @@
 	    	loadinfo.memsize += _ALIGN(0x100000, 0x1000);
 	    } else {
 	    	prom_printf("System.map load failed !\n");
-	    	prom_pause();
 	    }
 	}
-
-	/* If ramdisk, load it. For now, we can't tell the size it will be
-	 * so we claim an arbitrary amount of 4Mb
+	/* If ramdisk, load it if booting a vmlinux.  For now, we can't
+	 * tell the size it will be so we claim an arbitrary amount of 4Mb
 	 */
-	if (params.rd.file) {
+	if (booting_vmlinux && params.rd.file) {
 	    if(bootpath && !strcmp(bootpath,"\\\\") && params.rd.file[0] != '/')
 	    {
 		if (loc) free(loc);
@@ -939,52 +948,56 @@
 #endif	
 
 	/* 
-	 * Fill mew boot infos
-	 *
-	 * The birec is low on memory, probably inside the malloc pool, so
-	 * we don't write it earlier. At this point, we should not use anything
-	 * coming from the malloc pool
+	 * Fill new boot infos if booting a vmlinux.
 	 */
-	birec = (struct bi_record *)_ALIGN(loadinfo.filesize+(1<<20)-1,(1<<20));
+	if ( booting_vmlinux ) {
+	    /* 
+	     * The birec is low on memory, probably inside the malloc pool,
+	     * so we don't write it earlier. At this point, we should not
+	     * use anything coming from the malloc pool.
+	     */
+	    birec = (struct bi_record *)_ALIGN(loadinfo.filesize+(1<<20)-1,(1<<20));
+
+	    /* We make sure it's mapped. We map only 64k for now, it's plenty
+	     * enough we don't claim since this precise memory range may
+	     * already be claimed by the malloc pool.
+	     */
+	    prom_map (birec, birec, 0x10000);
 
-	/* We make sure it's mapped. We map only 64k for now, it's plenty enough
-	 * we don't claim since this precise memory range may already be claimed
-	 * by the malloc pool
-	 */
-	prom_map (birec, birec, 0x10000);
+	    prom_printf("Creating birec at address 0x%.8lx...\n", birec);
 #if DEBUG
-	prom_printf("birec at 0x%08lx\n", birec);
-	{
-	    int i = prom_getms();
-	    while((prom_getms() - i) < 2000)
-		;
-	}
+	    {
+	        int i = prom_getms();
+	        while((prom_getms() - i) < 2000)
+		    ;
+	    }
 #endif	
 
-	birec->tag = BI_FIRST;
-	birec->size = sizeof(struct bi_record);
-	birec = (struct bi_record *)((unsigned long)birec + birec->size);
+	    birec->tag = BI_FIRST;
+	    birec->size = sizeof(struct bi_record);
+	    birec = (struct bi_record *)((unsigned long)birec + birec->size);
 	
-	birec->tag = BI_BOOTLOADER_ID;
-	sprintf( (char *)birec->data, "yaboot");
-	birec->size = sizeof(struct bi_record) + strlen("yaboot") + 1;
-	birec = (struct bi_record *)((unsigned long)birec + birec->size);
+	    birec->tag = BI_BOOTLOADER_ID;
+	    sprintf( (char *)birec->data, "yaboot");
+	    birec->size = sizeof(struct bi_record) + strlen("yaboot") + 1;
+	    birec = (struct bi_record *)((unsigned long)birec + birec->size);
 	
-	birec->tag = BI_MACHTYPE;
-	birec->data[0] = _machine;
-	birec->size = sizeof(struct bi_record) + sizeof(unsigned long);
-	birec = (struct bi_record *)((unsigned long)birec + birec->size);
+	    birec->tag = BI_MACHTYPE;
+	    birec->data[0] = _machine;
+	    birec->size = sizeof(struct bi_record) + sizeof(unsigned long);
+	    birec = (struct bi_record *)((unsigned long)birec + birec->size);
 
-	if (sysmap_base) {
+	    if (sysmap_base) {
 		birec->tag = BI_SYSMAP;
 		birec->data[0] = (unsigned long)sysmap_base;
 		birec->data[1] = sysmap_size;
 		birec->size = sizeof(struct bi_record) + sizeof(unsigned long)*2;
 		birec = (struct bi_record *)((unsigned long)birec + birec->size);
+	    }
+	    birec->tag = BI_LAST;
+	    birec->size = sizeof(struct bi_record);
+	    birec = (struct bi_record *)((unsigned long)birec + birec->size);
 	}
-	birec->tag = BI_LAST;
-	birec->size = sizeof(struct bi_record);
-	birec = (struct bi_record *)((unsigned long)birec + birec->size);
 
 	/* compute the kernel's entry point. */
 	kernel_entry = loadinfo.base + loadinfo.entry - loadinfo.load_loc;
@@ -1099,10 +1112,21 @@
     prom_printf("Before prom_claim, mem_sz: 0x%08lx\n", loadinfo->memsize);
 #endif    
 
+    /* Determine whether we are trying to boot a vmlinux or some
+     * other binary image (eg, zImage).  We load vmlinux's at
+     * KERNELADDR and all other binaries at their e_entry value.
+     */
+    if (e->e_entry == KERNEL_LINK_ADDR_PPC32) {
+	booting_vmlinux = 1;
+	loadaddr = KERNELADDR;
+    } else {
+	booting_vmlinux = 0;
+	loadaddr = e->e_entry;
+    }
+
     /* On some systems, loadaddr may already be claimed, so try some
      * other nearby addresses before giving up.
      */
-    loadaddr = (e->e_entry == KERNEL_LINK_ADDR_PPC32) ? KERNELADDR : e->e_entry;
     for(addr=loadaddr; addr <= loadaddr * 8 ;addr+=0x100000) {
 	loadinfo->base = prom_claim((void *)addr, loadinfo->memsize, 0);
 	if (loadinfo->base != (void *)-1) break;
@@ -1242,10 +1266,21 @@
     prom_printf("Before prom_claim, mem_sz: 0x%08lx\n", loadinfo->memsize);
 #endif    
 
+    /* Determine whether we are trying to boot a vmlinux or some
+     * other binary image (eg, zImage).  We load vmlinux's at
+     * KERNELADDR and all other binaries at their e_entry value.
+     */
+    if (e->e_entry == KERNEL_LINK_ADDR_PPC64) {
+	booting_vmlinux = 1;
+	loadaddr = KERNELADDR;
+    } else {
+	booting_vmlinux = 0;
+	loadaddr = e->e_entry;
+    }
+
     /* On some systems, loadaddr may already be claimed, so try some
      * other nearby addresses before giving up.
      */
-    loadaddr = (e->e_entry == KERNEL_LINK_ADDR_PPC64) ? KERNELADDR : e->e_entry;
     for(addr=loadaddr; addr <= loadaddr * 8 ;addr+=0x100000) {
 	loadinfo->base = prom_claim((void *)addr, loadinfo->memsize, 0);
 	if (loadinfo->base != (void *)-1) break;
