#!/bin/bash
#
# a simple lilo to store the boot loader and the kernel images 
# in bash2 ... Think different [tm]
#
# olh@suse.de
# jplack@suse.de
#


# interprete a file like the following:


## Modified by YaST2. Last modification on Sun Mar  7 16:27:46 2004
##
##
## default = linux
## timeout = 100
## boot = /boot/suse_linux_bootfile
## boot = B
##
## image = /boot/vmlinux
##     ###Don't change this comment - YaST2 identifier: Original name: linux###
##     label = Linux
##     root = /dev/iseries/vda3
##     append = "hwinfo=-cdrom 3 desktop"
##


#CONFIG_LILO_CONF=~olh/ppc/lilo/lilo.conf
CONFIG_LILO_CONF=/etc/lilo.conf
SHOW_OF_PATH_SH=/bin/show_of_path.sh
DEFAULT_BOOTFOLDER=suseboot

if [ "$1" = "--lilo-rootdrive" ] ; then
    LILO_ROOTDRIVE=true
    shift
    SHOW_OF_PATH_SH="$SHOW_OF_PATH_SH --lilo-rootdrive $1"
    shift
fi

function running_on_chrp () {
    echo running on chrp

    #only the device is given and dd to the raw device is a bad idea
    if [ "$OPTION_PARTITION" = "" ] ; then
	echo guess the chrp boot device 
	PART=`fdisk -l $OPTION_DEVICE | fgrep "PPC PReP"`
	if [ -z "$PART" ] ; then
	    echo ERROR: config error, boot = $OPTION_BOOT is not 41 PReP  
	    echo '*********************************************************'
	    echo '* You must create a PPC PReP Boot partition (type 0x41) *'
	    echo '* for the CHRP bootloader to be installed.              *'
	    echo '*********************************************************'
	    exit -1
	fi
	if [ `echo "$PART" | wc -l` != 1 ] ; then
	    echo "ERROR: config error, guessing of boot partition failed"
	    echo "**************************************************************"
	    echo "* There are more than 1 PPC PReP Boot partitions (type 0x41) *"
	    echo "* on this system. Specify the partition NUMBER in boot= $OPTION_BOOT *"
	    echo "**************************************************************"
	    exit -1
	fi
	P=`echo "$PART" | awk '{print $1}'`
	
	echo Installing /lib/lilo/chrp/yaboot.chrp onto $P
	dd if=/lib/lilo/chrp/yaboot.chrp of=$P
	
	/sbin/activate $(echo "$P"|sed 's/[0-9]*$/ &/')
    else
	#we have the device, but better safe than sorry
	echo install on $OPTION_DEVICE
	PART=`fdisk -l $OPTION_DEVICE | grep $OPTION_BOOT | fgrep "PPC PReP"`
	if [ -z "$PART" ] ; then
	    echo "ERROR: config error, boot = $OPTION_BOOT is not 41 PReP"
	    echo "*********************************************************"
	    echo "* You must create a PPC PReP Boot partition (type 0x41) *"
	    echo "* for the CHRP bootloader to be installed.              *"
	    echo "*********************************************************"
	    exit -1
	fi
	echo Installing /lib/lilo/chrp/yaboot.chrp onto $OPTION_BOOT
	dd if=/lib/lilo/chrp/yaboot.chrp of=$OPTION_BOOT
	/sbin/activate $(echo "$OPTION_BOOT"|sed 's/[0-9]*$/ &/')
    fi

    echo check the image files
    for (( i=1; i<=CONFIG_IMAGE_COUNT; i++ )); do
	if [ -f ${CONFIG_IMAGE_FILE[$i]} ]; then
	    if df ${CONFIG_IMAGE_FILE[$i]} | grep -sq ^$OPTION_DEVICE ; then
		echo -n ${CONFIG_IMAGE_LABEL[$i]}
		test "${CONFIG_IMAGE_LABEL[$i]}" = "$OPTION_DEFAULT" && echo " *" || echo
	    else
		echo ERROR: image ${CONFIG_IMAGE_FILE[$i]} is not on bootdevice $OPTION_DEVICE
	    fi
	else
	    echo ERROR: image ${CONFIG_IMAGE_FILE[$i]} in ${CONFIG_IMAGE_LABEL[$i]} is missing
	fi
    done
    # starting the work and write the yaboot.conf
    {
	test -z "$OPTION_TIMEOUT" || echo "timeout = $OPTION_TIMEOUT"
	test -z "$OPTION_DEFAULT" || echo "default = $OPTION_DEFAULT"
	test -z "$OPTION_ROOT"    || echo "root = $OPTION_ROOT"
	test -z "$OPTION_APPEND"  || echo "append = \"$OPTION_APPEND\""
	test -z "$OPTION_INITRD"  || echo "initrd = $OPTION_INITRD"
	
	for i in `seq 1 $CONFIG_IMAGE_COUNT` ; do
	    test -z "${CONFIG_IMAGE_OTHER[$i]}" || continue
	    # hack to create a zImage.initrd for pseries
	    # ugly ugly ...
	    #
	    #  is no longer needed due to olh 9.3.2004
	    #if [ ! -z "${CONFIG_IMAGE_INITRD[$i]}" -a -d /proc/ppc64 ]; then
		#if ! bash /lib/lilo/chrp/chrp64/addRamdisk.sh \
		 # /tmp/ppc_lilo \
		 # ${CONFIG_IMAGE_FILE[$i]} \
		 # ${CONFIG_IMAGE_INITRD[$i]} \
		 # ${CONFIG_IMAGE_FILE[$i]}.initrd \
		 # > /tmp/ppc_lilo/chrp_initrd_$i.log 2>&1 ; then
		 #   cat /tmp/ppc_lilo/chrp_initrd_$i.log
		 #   exit 1
		#fi
		#
		#CONFIG_IMAGE_FILE[$i]=${CONFIG_IMAGE_FILE[$i]}.initrd
		#unset CONFIG_IMAGE_INITRD[$i]
	    #fi
	    echo "image = ${CONFIG_IMAGE_FILE[$i]}"
	    test -z "${CONFIG_IMAGE_LABEL[$i]}"  || echo "    label = ${CONFIG_IMAGE_LABEL[$i]}"
	    test -z "${CONFIG_IMAGE_ROOT[$i]}"   || echo "    root = ${CONFIG_IMAGE_ROOT[$i]}"
	    test -z "${CONFIG_IMAGE_APPEND[$i]}" || echo "    append = \"${CONFIG_IMAGE_APPEND[$i]}\""
	    test -z "${CONFIG_IMAGE_SYSMAP[$i]}" || echo "    sysmap = ${CONFIG_IMAGE_SYSMAP[$i]}"
	    test -z "${CONFIG_IMAGE_INITRD[$i]}" || echo "    initrd = ${CONFIG_IMAGE_INITRD[$i]}"
	done
    } > /tmp/ppc_lilo/yaboot.conf
    cp -av /tmp/ppc_lilo/yaboot.conf /etc/yaboot.conf
}



function running_on_iseries () {
    echo running on iSeries
    ISERIES_KERNEL_TMPFILE=/tmp/ppc_lilo/vmlinux.initrd
    
    if [ ! -z "$OPTION_DEFAULT" ] ; then
	# find the default= line
	for ((i=1; i<=CONFIG_IMAGE_COUNT; i++)); do
	    if [ "$OPTION_DEFAULT" =  "${CONFIG_IMAGE_LABEL[$i]}" ] ; then
		ISERIES_IMAGE="${CONFIG_IMAGE_FILE[$i]}" 
		if [ -n "$OPTION_APPEND" ] ; then
		    ISERIES_CMDLINE=$OPTION_APPEND
		fi
		if [ -n "${CONFIG_IMAGE_APPEND[$i]}" ] ; then
		    ISERIES_CMDLINE=${CONFIG_IMAGE_APPEND[$i]}
		fi
		if [ -n "$OPTION_ROOT" ] ; then
		    ISERIES_ROOT="root=$OPTION_ROOT"
		fi
		if [ -n "${CONFIG_IMAGE_ROOT[$i]}" ] ; then
		    ISERIES_ROOT="root=${CONFIG_IMAGE_ROOT[$i]}"
		fi
		if [ -n "$OPTION_INITRD" ] ; then
		    ISERIES_INITRD=$OPTION_INITRD
		fi
		if [ -n "${CONFIG_IMAGE_INITRD[$i]}" ] ; then
		    ISERIES_INITRD="${CONFIG_IMAGE_INITRD[$i]}"
		fi
	    fi
	done
    else
	# pick the first image= line
	ISERIES_IMAGE="${CONFIG_IMAGE_FILE[1]}"
	if [ -n "$OPTION_APPEND" ] ; then
	    ISERIES_CMDLINE=$OPTION_APPEND
	fi
	if [ -n "${CONFIG_IMAGE_APPEND[1]}" ] ; then
	    ISERIES_CMDLINE=${CONFIG_IMAGE_APPEND[1]}
	fi
	if [ -n "$OPTION_ROOT" ] ; then
	    ISERIES_ROOT="root=$OPTION_ROOT"
	fi
	if [ -n "${CONFIG_IMAGE_ROOT[1]}" ] ; then
	    ISERIES_ROOT="root=${CONFIG_IMAGE_ROOT[1]}"
	fi
	if [ -n "$OPTION_INITRD" ] ; then
	    ISERIES_INITRD=$OPTION_INITRD
	fi
	if [ -n "${CONFIG_IMAGE_INITRD[1]}" ] ; then
	    ISERIES_INITRD="${CONFIG_IMAGE_INITRD[1]}"
	fi
    fi
    
    #
    #  loop for multiple OPTION_BOOT entries
    #
    for (( i=0; i<OPTION_BOOT_COUNT; i++ )); do

	ISERIES_BOOT="${OPTION_BOOT[$i]##*=}"
	ISERIES_DEVICE="${OPTION_DEVICE[$i]}" 
	ISERIES_BOOT_IMAGE="$ISERIES_IMAGE"

	echo "ISERIES_CMDLINE " $ISERIES_CMDLINE
	echo "ISERIES_ROOT    " $ISERIES_ROOT
	echo "ISERIES_IMAGE   " $ISERIES_IMAGE
	echo "ISERIES_BOOT    " $ISERIES_BOOT

	if [ -n "$ISERIES_INITRD" ]; then
	    echo "ISERIES_INITRD  " $ISERIES_INITRD
	    echo
	    echo generating $ISERIES_KERNEL_TMPFILE with /lib/lilo/iseries/iseries-addRamDisk
	    echo
	    echo
	    unset ec
	    /lib/lilo/iseries/iseries-addRamDisk \
	      $ISERIES_INITRD \
	      /boot/System.map-`get_kernel_version $ISERIES_IMAGE` \
	      $ISERIES_IMAGE \
	      $ISERIES_KERNEL_TMPFILE ; ec=$?
	    echo
	    if [ "$ec" != "0" ]; then
		echo bootfile generation failed: ec $ec ;
		exit 1 ;
	    fi
	    ISERIES_BOOT_IMAGE=$ISERIES_KERNEL_TMPFILE
	fi
	echo ISERIES_BOOT_IMAGE $ISERIES_BOOT_IMAGE
	unset ISERIES_TARGET
	if [[ "$ISERIES_BOOT" == [AB] ]]; then
	    ISERIES_TARGET=slot
	elif [ -c "$ISERIES_BOOT" -o -d "$ISERIES_BOOT" -o -p "$ISERIES_BOOT" -o -S "$ISERIES_BOOT" ]; then
	    ISERIES_TARGET=invalid
	elif [ -b "$ISERIES_BOOT" ]; then
	    ISERIES_TARGET=block_dev
	elif [ -f "$ISERIES_BOOT" -o ! -e "$ISERIES_BOOT" ]; then
	    ISERIES_TARGET=file
	else
	    ISERIES_TARGET=invalid
	fi
    
	case "$ISERIES_TARGET" in
	  slot)
		echo write to slot $ISERIES_BOOT
		;;
	  file)
		if [ "${ISERIES_BOOT:0:1}" != "/" ] ; then
		    echo boot=$ISERIES_BOOT must have an absolute path
		    case "$ISERIES_BOOT" in
		      a|b|c)
			     echo "Did you mean uppercase '$ISERIES_BOOT'?"
			     ;;
		    esac
		    exit 1
		fi
		echo write to file $ISERIES_BOOT
		rm -f $ISERIES_BOOT
		cp -a $ISERIES_BOOT_IMAGE $ISERIES_BOOT
		;;
	  block_dev)
		     echo write to block_dev "$ISERIES_BOOT"
		     ;;
	  invalid)
		   echo "Error: boot=$ISERIES_BOOT invalid"
		   exit 1
		   ;;
	esac
	
	if [ "$ISERIES_TARGET" = "slot" -a -n "$ISERIES_BOOT_IMAGE" -a -f "$ISERIES_BOOT_IMAGE" ] ; then
	    echo "this will take a while... ($[$(ls -l $ISERIES_BOOT_IMAGE | awk '{ print $5 }') / 1024] kb)"
	    echo "writing kernel $ISERIES_BOOT_IMAGE to /proc/iSeries/mf/$ISERIES_BOOT/vmlinux"
	    dd if=$ISERIES_BOOT_IMAGE of=/proc/iSeries/mf/$ISERIES_BOOT/vmlinux bs=4096
	    echo activate kernel slot $ISERIES_BOOT in /proc/iSeries/mf/side
	    echo $ISERIES_BOOT > /proc/iSeries/mf/side
	        
	    # remove any old cmdline content, leads to newlines
	    dd if=/dev/zero of=/proc/iSeries/mf/$ISERIES_BOOT/cmdline count=1 bs=254
	    echo "$ISERIES_ROOT $ISERIES_CMDLINE" > /proc/iSeries/mf/$ISERIES_BOOT/cmdline
	fi
    
    
	if [ "$ISERIES_TARGET" = "block_dev" ]; then
	    #only the device is given and dd to the raw device is a bad idea
	    if [ "${OPTION_PARTITION[$i]}" = "" ]; then
		echo guess the prep boot device 
		PART=`fdisk -l $ISERIES_DEVICE | fgrep "PPC PReP"`
		if [ -z "$PART" ] ; then
		    echo ERROR: config error, boot = $ISERIES_BOOT is not 41 PReP  
		    echo '**********************************************************'
		    echo '* You could create a PPC PReP Boot partition (type 0x41) *'
		    echo '* for the kernel binary to be installed.                 *'
		    echo '**********************************************************'
		    exit -1
		fi
		if [ `echo "$PART" | wc -l` != 1 ] ; then
		    echo "ERROR: config error, guessing of boot partition failed"
		    echo "**************************************************************"
		    echo "* There are more than 1 PPC PReP Boot partitions (type 0x41) *"
		    echo "* on this system. Specify the partition NUMBER in boot= $ISERIES_BOOT *"
		    echo "**************************************************************"
		    exit -1
		fi
		P=`echo "$PART" | awk '{print $1}'`
		
		echo Installing "$ISERIES_BOOT_IMAGE" onto $P
		dd if="$ISERIES_BOOT_IMAGE" of=$P bs=4096
		    
	    	echo set active flag on partition $(echo "$P"|sed 's/[0-9]*$/ &/')
	    	/sbin/activate $(echo "$P"|sed 's/[0-9]*$/ &/')
	    else
		#we have the device, but better safe than sorry
		echo install on $ISERIES_DEVICE
		PART=`fdisk -l $ISERIES_DEVICE | grep $ISERIES_BOOT | fgrep "PPC PReP"`
		if [ -z "$PART" ] ; then
		    echo "ERROR: config error, boot = $ISERIES_BOOT is not 41 PReP"
		    echo '**********************************************************'
		    echo "* You could create a PPC PReP Boot partition (type 0x41) *"
		    echo '* for the kernel binary to be installed.                 *'
		    echo '**********************************************************'
		    exit -1
		fi
		
		echo Installing "$ISERIES_BOOT_IMAGE" onto $ISERIES_BOOT
		dd if="$ISERIES_BOOT_IMAGE" of=$ISERIES_BOOT bs=4096
		    
	    	echo set active flag on partition $(echo "$ISERIES_BOOT"|sed 's/[0-9]*$/ &/')
	    	/sbin/activate $(echo "$ISERIES_BOOT"|sed 's/[0-9]*$/ &/')
	    fi
	fi
    done  #  end of OPTION_BOOT loop
}





function running_on_prep () {

    echo running on prep
    #only the device is given and dd to the raw device is a bad idea
    
    if [ "$OPTION_PARTITION" = "" ] ; then
	echo guess the prep boot device 
	PART=`fdisk -l $OPTION_DEVICE | fgrep "PPC PReP"`
	if [ -z "$PART" ] ; then
	    echo ERROR: config error, boot = $OPTION_BOOT is not 41 PReP  
	    echo '*********************************************************'
	    echo '* You must create a PPC PReP Boot partition (type 0x41) *'
	    echo '* for the CHRP bootloader to be installed.              *'
	    echo '*********************************************************'
	    exit -1
	fi
	if [ `echo "$PART" | wc -l` != 1 ] ; then
	    echo "ERROR: config error, guessing of boot partition failed"
	    echo "**************************************************************"
	    echo "* There are more than 1 PPC PReP Boot partitions (type 0x41) *"
	    echo "* on this system. Specify the partition NUMBER in boot= $OPTION_BOOT *"
	    echo "**************************************************************"
	    exit -1
	fi
	P=`echo "$PART" | awk '{print $1}'`
	
	echo Installing /boot/zImage.prep onto $P
	dd if=/boot/zImage.prep of=$P
	    /sbin/activate $(echo "$P"|sed 's/[0-9]*$/ &/')
    else
	#we have the device, but better safe than sorry
	echo install on $OPTION_DEVICE
	PART=`fdisk -l $OPTION_DEVICE | grep $OPTION_BOOT | fgrep "PPC PReP"`
	if [ -z "$PART" ] ; then
	    echo "ERROR: config error, boot = $OPTION_BOOT is not 41 PReP"
	    echo "*********************************************************"
	    echo "* You must create a PPC PReP Boot partition (type 0x41) *"
	    echo "* for the CHRP bootloader to be installed.              *"
	    echo "*********************************************************"
	    exit -1
	fi
	echo Installing /boot/zImage.prep onto $OPTION_BOOT
	dd if=/boot/zImage.prep of=$OPTION_BOOT
	    /sbin/activate $(echo "$OPTION_BOOT"|sed 's/[0-9]*$/ &/')
    fi
    
    echo check the image files
    for i in `seq 1 $CONFIG_IMAGE_COUNT` ; do
	if test -f ${CONFIG_IMAGE_FILE[$i]} ; then
	    if df ${CONFIG_IMAGE_FILE[$i]}|grep -sq ^$OPTION_DEVICE ; then
		echo -n ${CONFIG_IMAGE_LABEL[$i]}
		test "${CONFIG_IMAGE_LABEL[$i]}" = "$OPTION_DEFAULT" && echo " *" || echo
	    else
		echo ERROR: image ${CONFIG_IMAGE_FILE[$i]} is not on bootdevice $OPTION_DEVICE
	    fi
	else
	    echo ERROR: image ${CONFIG_IMAGE_FILE[$i]} in ${CONFIG_IMAGE_LABEL[$i]} is missing
	fi
    done
}


function running_on_pmac_old () {
    source /lib/lilo/lilo-pmac.lib
    running_on_pmac_old;
}


function running_on_pmac_new () {
    source /lib/lilo/lilo-pmac.lib
    running_on_pmac_new;
}



function check_arch () {
    # check for the current ppc subarch
    unset COPY_BOOT_FILES
    while read line; do
	case "$line" in
	  #		dont force copy on new macs until yaboot is fixed
	  #		*MacRISC2*)	MACHINE="pmac" ; COPY_BOOT_FILES="true" ;;
	  *MacRISC*)	MACHINE="pmac" ;;
	  *CHRP*)		MACHINE="chrp" ;;
	  *PReP*)		MACHINE="prep" ;;
	  *iSeries*)	MACHINE="iseries" ;;
	esac
    done < /proc/cpuinfo
    
    if [ "$MACHINE" = "pmac" ] ; then
	if [ -f /proc/device-tree/openprom*/model ] ; then
	    echo `cat /proc/device-tree/openprom*/model` > /tmp/ppc_lilo/openprom_model
	    while read openfirmware ofversion; do
		case "$openfirmware" in
		  iMac,1|OpenFirmware)      MACHINE="pmac_new" ;;
		  Open)      MACHINE="pmac_old" ;;
		esac
	    done < /tmp/ppc_lilo/openprom_model
	fi
    fi
} #end function check_arch


function prepare_config_file () {
    # strip comments and empty lines
    
    grep -v "#.*$" < $CONFIG_LILO_CONF | grep -v "\(^\W$\|^$\)" | sed 's/=/ & /' > /tmp/ppc_lilo/config_tmp
    
    #"
} #end function prepare_config_file


function parse_config_file () {
    # parse the lilo.conf and place it in CONFIG_IMAGE_FILE[]
    # other vars:
    # OPTION_BOOT is an array to contains the bootloader partition and/or targets
    # OPTION_BOOT_COUNT is a counter to the array above
    # OPTION_OTHER contains the MacOS partition
    # OPTION_BOOTFOLDER contains the MacOS folder with the bootstuff
    # OPTION_ACTIVATE is a flag whether or not the boot partition must be set active in OF
    # OPTION_TIMEOUT contains the timeout variable in seconds
    # OPTION_DEFAULT contains the default label
    # OPTION_ROOT contains the global or local root= device
    # OPTION_APPEND contains the global or local append= strings
    # OPTION_INITRD containes the global or local initrd filename
    # OPTION_IMAGE_COPY contains a flag to force copy to the boot partition
    # internal vars:
    # CONFIG_PARSE_HASIMAGE is a flag if we have a image section.
    # CONFIG_IMAGE_FILE contains the kernel image for a section
    # CONFIG_IMAGE_OTHER contains the device of MacOS
    # CONFIG_IMAGE_COUNT is a simple counter of image sections
    
    unset CONFIG_PARSE_HASIMAGE
    CONFIG_IMAGE_COUNT=0
    OPTION_BOOT_COUNT=0
    while read option sarator value ; do
	
	#	echo option "$option"
	#	echo sarator "$sarator"
	#	echo value $value
	case "$option" in
	  boot)
		if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		    OPTION_BOOT[$OPTION_BOOT_COUNT]="$value"
		    (( OPTION_BOOT_COUNT++ ))
		else 
		    echo boot option must not in an image section!
		    exit 1
		fi
		;;
	  activate)
		    if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
			OPTION_ACTIVATE="yes"
		    else 
			echo activate option must not in an image section!
			exit 1
		    fi
		    ;;
	  progressbar)
		       # do nothing
		       ;;
	  bootfolder)
		      if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
			  OPTION_BOOTFOLDER=":${value}"
		      else 
			  echo bootfolder option must not in an image section!
			  exit 1
		      fi
		      ;;
	  timeout)
		   if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		       OPTION_TIMEOUT=$value
		   else
		       echo timeout option must not in an image section!
		       exit 1
		   fi
		   ;;
	  default)
		   if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		       OPTION_DEFAULT=$value
		   else
		       echo default option must not in an image section!
		       exit 1
		   fi
		   ;;
	  image)
		 # check if previous image section has a label
		 if [ ! -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		     if [ -z "${CONFIG_IMAGE_LABEL[$CONFIG_IMAGE_COUNT]}" ] ; then
			 echo ERROR: config error, no label in image = ${CONFIG_IMAGE_FILE[$CONFIG_IMAGE_COUNT]}
		     fi
		 fi
		 CONFIG_PARSE_HASIMAGE=true
		 (( CONFIG_IMAGE_COUNT++ ))
		 CONFIG_IMAGE_FILE[$CONFIG_IMAGE_COUNT]=$value
		 ;;
	  other)
		 # check if previous image section has a label
		 if [ -n "$CONFIG_PARSE_HASIMAGE" ] ; then
		     if [ -z "${CONFIG_IMAGE_LABEL[$CONFIG_IMAGE_COUNT]}" ] ; then
			 echo ERROR: config error, no label in image = ${CONFIG_IMAGE_FILE[$CONFIG_IMAGE_COUNT]}
		     fi
		 fi
		 CONFIG_PARSE_HASIMAGE=true
		 CONFIG_PARSE_HASOTHER=true
		 (( CONFIG_IMAGE_COUNT++ ))
		 CONFIG_IMAGE_OTHER[$CONFIG_IMAGE_COUNT]=$value
		 OPTION_OTHER=$value
		 ;;
	  root)
		if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		    OPTION_ROOT=$value
		else
		    CONFIG_IMAGE_ROOT[$CONFIG_IMAGE_COUNT]=$value
		fi
		;;
	  copy)
		if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		    echo ERROR: config error, label option must be in an image section!
		    exit 1
		else
		    CONFIG_IMAGE_COPY[$CONFIG_IMAGE_COUNT]="true"
		fi
		;;
	  label)
		 if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		     echo ERROR: config error, label option must be in an image section!
		     exit 1
		 else
		     CONFIG_IMAGE_LABEL[$CONFIG_IMAGE_COUNT]=$value
		 fi
		 ;;
	  append)
		  if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		      # use eval to strip ""
		      eval OPTION_APPEND=$value
		  else
		      # use eval to strip ""
		      eval CONFIG_IMAGE_APPEND[$CONFIG_IMAGE_COUNT]=$value
		  fi
		  ;;
	  sysmap)
		  if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		      echo "ERROR: sysmap can not be global"
		      exit 1
		  else
		      CONFIG_IMAGE_SYSMAP[$CONFIG_IMAGE_COUNT]=$value
		  fi
		  
		  ;;
	  initrd)
		  if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		      OPTION_INITRD=$value
		  else
		      CONFIG_IMAGE_INITRD[$CONFIG_IMAGE_COUNT]=$value
		  fi
		  ;;		
	  *)
	     echo !!!!!!!!!! unkown option $option !!!!!!!!!!!!!
	     exit 1
	     ;;
	esac
    done < /tmp/ppc_lilo/config_tmp
    
    
} #end function parse_config_file


function check_config_file () {

    if [ "$MACHINE" != "iseries" ]; then
	if [ ! -b $OPTION_BOOT ]; then
	    echo ERROR: boot = $OPTION_BOOT is not a valid block device
	    exit -1 
	fi
	if [ -z "$OPTION_BOOT" ]; then
	    echo "ERROR: boot= is not specified!"
	    exit -1
	fi
	if [ $OPTION_BOOT_COUNT -ne 1 ]; then
	    echo "ERROR: only one boot= line allowed here!"
	    exit -1
	fi
    fi
    
    if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
	echo ERROR: no image section is specified
	exit -1
    fi
    
    for i in `seq 1 $CONFIG_IMAGE_COUNT` ; do
	if [ ! -f ${CONFIG_IMAGE_FILE[$i]} ] ; then
	    echo "ERROR: image = ${CONFIG_IMAGE_FILE[$i]} ist not a regular file"
	    exit -1
	fi
	if [ ! -f ${CONFIG_IMAGE_INITRD[$i]} ] ; then
	    echo "ERROR: initrd = ${CONFIG_IMAGE_INITRD[$i]} ist not a regular file"
	    exit -1
	fi
	if [ ! -f ${CONFIG_IMAGE_SYSMAP[$i]} ] ; then
	    echo "ERROR: sysmap = ${CONFIG_IMAGE_SYSMAP[$i]} ist not a regular file"
	    exit -1
	fi
    done
    
    #
    #  loop for multiple OPTION_BOOT entries
    #
    for (( i=0; i<OPTION_BOOT_COUNT; i++ )); do
	# TODO: check whether patterns are still valid !?
	OPTION_DEVICE[$i]=`echo "$OPTION_BOOT[$i]"|sed 's/[0-9]*$/ &/'|cut -d " " -f 1`
	OPTION_NODENAME[$i]=`echo "$OPTION_DEVICE[$i]"|sed 's/[0-9]*$/ &/'|cut -d "/" -f 3`
	OPTION_PARTITION[$i]=`echo "$OPTION_BOOT[$i]"|sed 's/[0-9]*$/ &/'|cut -d " " -f 2`
    done

} #end function check_config_file



function prepare_envoirement () {
    rm -f /tmp/ppc_lilo/* 2>/dev/null
    mkdir -p /tmp/ppc_lilo/
} #end function prepare_envoirement

#
# here we go
#

prepare_envoirement
check_arch
prepare_config_file
parse_config_file
check_config_file

case "$MACHINE" in
	pmac_new)  running_on_pmac_new ;;
	pmac_old)  running_on_pmac_old ;;
	chrp)	   running_on_chrp     ;;
	prep)	   running_on_prep     ;;
	iseries)   running_on_iseries  ;;
esac

#
#for i in `seq 1 $CONFIG_IMAGE_COUNT`;do
#	echo section $i:
#	echo image  ${CONFIG_IMAGE_FILE[$i]}
#	echo label  ${CONFIG_IMAGE_LABEL[$i]}
#	echo append ${CONFIG_IMAGE_APPEND[$i]}
#	echo initrd ${CONFIG_IMAGE_INITRD[$i]}
#	echo root   ${CONFIG_IMAGE_ROOT[$i]}
#done
#
# set | less

#
#
# Local variables:
#     mode: ksh
#     ksh-indent: 4
#     ksh-multiline-offset: 2
#     ksh-if-re: "\\s *\\b\\(if\\)\\b[^=]"
# End:
#

