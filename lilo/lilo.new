#!/bin/bash
#
# a simple lilo to store the boot loader and the kernel images 
# in bash2 ... Think different [tm]
#
# olh@suse.de
# jplack@suse.de
#


# interprete a file like the following:


## Modified by YaST2. Last modification on Sun Mar  7 16:27:46 2004
##
##
## default = linux
## timeout = 100
## boot = /boot/suse_linux_bootfile
## boot = B
##
## image = /boot/vmlinux
##     ###Don't change this comment - YaST2 identifier: Original name: linux###
##     label = Linux
##     root = /dev/iseries/vda3
##     append = "hwinfo=-cdrom 3 desktop"
##

# Language kills all parsing effort
unset LANG
unset LC_CTYPE

#CONFIG_LILO_CONF=~olh/ppc/lilo/lilo.conf
CONFIG_LILO_CONF=/etc/lilo.conf
SHOW_OF_PATH="/bin/show_of_path.sh --quiet"
DEFAULT_BOOTFOLDER=suseboot
TEMP="${TMPDIR:-/tmp}/ppc_lilo"

shopt -s extglob


## requires    fdisk   parted  stat

FDISK=/sbin/fdisk
PARTED="/usr/sbin/parted -s"
STAT_CMD=/usr/bin/stat


#
#  parse options
#

function Usage() {
    # TODO: print a usage message that makes sense ...
    echo "Usage: lilo <currently no options supported>"
}


function error() {
    # helper function to print _all_ error messages in a unified form
    # argument list consists of a list of msg numbers and custom strings
    until  [ "$#" = 0 ] ; do
	case "$1" in
	    1)
	        echo '************************************************************'
	       	echo '* You must create a PPC PReP Boot partition (type 0x41) or *'
	       	echo '* a FAT partition for the CHRP bootloader to be installed. *'
	       	echo '************************************************************'
		;;
	    2)
	       	echo '************************************************************'
	       	echo '* There is more than one PPC PReP Boot (type 0x41) or FAT  *'
	       	echo '* on this system. Please specify the boot partition NUMBER *'
	       	printf '* in boot= %-30s                  *\n' $OPTION_BOOT
	       	echo '************************************************************'
		;;
	    3)
	        echo '************************************************************'
		echo '* You have to create a PPC PReP Boot partition (type 0x41) *'
		echo '* for the kernel binary to be installed.                   *'
		echo '************************************************************'
		;;
	    4)
       	    	echo '************************************************************'
	    	echo '* You have to create a PPC PReP Boot partition (type 0x41) *'
	    	echo '* for the CHRP bootloader to be installed.                 *'
	    	echo '************************************************************'
		;;
	    5)
	       	echo '************************************************************'
	       	echo '* There is more than one PPC PReP Boot partition (type     *'
	       	echo '* 0x41) on this system. Please specify the boot partition  *'
	        printf '* NUMBER in boot = %-30s          *\n' $err_var1
	       	echo '************************************************************'
		;;
	    6)
	        echo "ERROR: config error, no label in section image/other = $err_var1"
		;;
	    7)
	        echo "ERROR: config error, $option option must not be in an image/other section!"
		;;
	    8)
		echo "ERROR: config error, $option option must be in an image/other section!"
		;;
	    *)  # plain custom string
	        echo "ERROR: $1"
		;;
	esac >&2
	shift
    done   
    exit 1
}


function get_of_path() {
    local errnum=$?

    $SHOW_OF_PATH $1
    errnum=$?

    if (( errnum != 0 )); then
	error "show_of_path.sh returned error $errnum while analysing path $1"
    fi
}


function div1000() {
    local s=$1
    while (( ${#s} < 4 )); do s="0$s"; done
    echo ${s%???}.${s:$[${#s}-3]}
}


while [ "$1" ]; do case "$1" in
    #--lilo-rootdrive)
    #    if ! [ "$2" ]; then
    #	    echo "lilo: no rootdrive given on command line"
    #	    Usage;
    #	    exit 1;
    #	fi
    #	
    #   LILO_ROOTDRIVE=true
    #   shift
    #   SHOW_OF_PATH="$SHOW_OF_PATH --lilo-rootdrive $1"
    #   shift
    #   ;;
    *)
        echo 1>&2 "lilo: Option \"$1\" not supported"
	Usage;
        exit 1
	;;
esac; done


function running_on_chrp () {
    echo running on chrp

    # find all PReP boot and FAT partitions
    local -a prep_part fat_part fat32_part

    while read; do
	local device start end blocks id system
	[ "${REPLY:0:1}" = "/" ] || continue
	REPLY="${REPLY/\\*}"  # remove all 'bootable' markers
	read device start end blocks id system <<< "$REPLY"

	case $id in
	  41) # PReP boot partition
	      prep_part=(${prep_part[*]} $device)
	      ;;
	  6)  # FAT16 partition
	      fat_part=(${fat_part[*]} $device)
	      ;;
	  c) # FAT32 partition
	      fat32_part=(${fat32_part[*]} $device)
	      ;;
	esac
	# please note: an empty boot= will cause a full disk scan of
	# the system
    done < <( $FDISK -l $OPTION_DEVICE )

    # check all mounted local file systems
    local -a fsys
    local device mount type opts

    while read device mount type opts; do
	if [ "${device:0:1}" = "/" ]; then
	    local -i dn=$(device_nr $device)
	    (( dn == 0 )) && continue;
	    fsys[$dn]="$type";
	    # echo  fsys[$device/$dn]="$type"
	fi
    done < /proc/mounts

    # only the device is given and dd to the raw device is a bad idea
    # Note: An empty boot= results in an empty OPTION_PARTITION which triggers
    # the guessing magic
    if [ -z "$OPTION_PARTITION" ] ; then
	echo guessing the chrp boot device
	case $[${#prep_part[*]} + ${#fat_part[*]}] in
	    1)
	       	OPTION_BOOT=$prep_part
	       	[ "$OPTION_BOOT" ] || OPTION_BOOT=$fat_part
	       	;;
            0)
		# special case: YaST2 does not give the option for FAT16 but
		# only for FAT32 so allow that as a special case
		
		if [ ${#fat32_part[*]} == 1 ]; then
		    OPTION_BOOT=$fat32_part
		else
	            error "in config file, boot = $OPTION_BOOT is not 41 PReP nor FAT"  1
		fi
	       	;;
	    *)
	       	error "in config file, guessing of boot partition failed" 2
	       	;;
 	esac
    else
	# we have the device, but better safe than sorry
	if [[ "${prep_part[*]} ${fat_part[*]} ${fat32_part[*]}" != *$OPTION_BOOT* ]]; then
	    error "in config file, boot = $OPTION_BOOT is not 41 PReP nor FAT"  1
	fi
    fi
    echo Boot target is ${OPTION_BOOT%%+([0-9])}

    # check all CONFIG_IMAGE_FILEs whether they are on ext2/ext2/fat/reiserfs
    # else they have to be copied to a fat partition
    # You have to create a fat partiton if any has to be copied there
    # fat partition must at least cover yaboot.fat,yaboot.cnf & default image
    # if not give a fatal error
    # else if it covers not all give a warning and advice how to fix that. 
	
    local -a vmlinux_copy initrd_copy
    local -i vmlinux_nr=0 initrd_nr=0
    local -i vmlinux_default=0 initrd_default=0
    local path_boot=$(get_of_path $OPTION_BOOT)

    # starting the work and write the yaboot.conf
    {
	echo "# header section"
	test -z "$OPTION_TIMEOUT" || echo "timeout = $OPTION_TIMEOUT"
	test -z "$OPTION_DEFAULT" || echo "default = $OPTION_DEFAULT"
	test -z "$OPTION_ROOT"    || echo "root = $OPTION_ROOT"
	test -z "$OPTION_APPEND"  || echo "append = \"$OPTION_APPEND\""
	test -z "$OPTION_INITRD"  || echo "initrd = $OPTION_INITRD"
	
	echo "# image section"
	for (( i=1; i<=CONFIG_IMAGE_COUNT; i++ )); do
	    if [ "${CONFIG_IMAGE_OTHER[$i]}" ]; then
		echo >&2 "Warning: There is no chain loader support for yaboot yet"
		echo >&2 "         Entry 'other = ${CONFIG_IMAGE_OTHER[$i]}' ignored"
		continue
	    fi

	    # hack to create a zImage.initrd for pseries
	    # ugly ugly ...
	    #
	    #  is no longer needed due to olh 9.3.2004
	    # still needed, might be a bug in yaboot 26.3.2004
	    if false && [ -n "${CONFIG_IMAGE_INITRD[$i]}" -a -d /proc/ppc64 ]; then
		if ! bash /lib/lilo/chrp/chrp64/addRamdisk.sh $TEMP \
		  ${CONFIG_IMAGE_FILE[$i]} \
		  ${CONFIG_IMAGE_INITRD[$i]} \
		  ${CONFIG_IMAGE_FILE[$i]}.initrd \
		  > $TEMP/chrp_initrd_$i.log 2>&1 ; then
		    cat $TEMP/chrp_initrd_$i.log
		    exit 1
		fi
		
		CONFIG_IMAGE_FILE[$i]=${CONFIG_IMAGE_FILE[$i]}.initrd
		unset CONFIG_IMAGE_INITRD[$i]
	    fi

	    if [ -f ${CONFIG_IMAGE_FILE[$i]} ]; then
		local image="${CONFIG_IMAGE_FILE[$i]}"
		local path_image=$(get_of_path $image)
		local devnr_image=$(device_of_file $image) 
		
		# check whether the image file lies on a file system that is
		# readable by yaboot
		if [ "$path_image" ] && [[ "${fsys[$devnr_image]}" == @(ext2|ext3|msdos|vfat|reiserfs|iso9660|xfs) ]]; then
		    # Is boot image file on the same device from where yaboot started?
		    if [ "${path_image:0:${#path_boot}}" = "$path_boot" ]; then
			CONFIG_IMAGE_FILE[$i]="$image"
			# test "${CONFIG_IMAGE_LABEL[$i]}" = "$OPTION_DEFAULT" && echo " *" || echo
		    else
			CONFIG_IMAGE_FILE[$i]="${path_image}"
		    fi
		else
		    # image file needs to be copied to the boot device which has to
		    # be a FAT file system and be large enough to hold all data
		    let vmlinux_nr++
		    if [ "${CONFIG_IMAGE_LABEL[$i]}" = "$OPTION_DEFAULT" ]; then
			vmlinux_default=$vmlinux_nr
		    fi
		    vmlinux_copy[$vmlinux_nr]="$image"
		    CONFIG_IMAGE_FILE[$i]=$(printf "vmlinux.%03d\n" $vmlinux_nr)
		fi
	    else
		echo >&2 "Warning: image ${CONFIG_IMAGE_FILE[$i]} in ${CONFIG_IMAGE_LABEL[$i]} is missing"
		echo >&2 "         Entry ignored"
		continue
	    fi

	    if [ "${CONFIG_IMAGE_INITRD[$i]}" -a -f "${CONFIG_IMAGE_INITRD[$i]}" ]; then
		local image="${CONFIG_IMAGE_INITRD[$i]}"
		local path_image=$(get_of_path $image)
		local devnr_image=$(device_of_file $image) 
		
		# check whether the image file lies on a file system that is
		# readable by yaboot
		if [ "$path_image" ] && [[ "${fsys[$devnr_image]}" == @(ext2|ext3|msdos|vfat|reiserfs|iso9660|xfs) ]]; then
		    # Is boot image file on the same device from where yaboot started?
		    if [ "${path_image:0:${#path_boot}}" = "$path_boot" ]; then
			CONFIG_IMAGE_INITRD[$i]="$image"
			# test "${CONFIG_IMAGE_LABEL[$i]}" = "$OPTION_DEFAULT" && echo " *" || echo
		    else
			CONFIG_IMAGE_INITRD[$i]="${path_image}"
		    fi
		else
		    # image file needs to be copied to the boot device which has to
		    # be a FAT file system and be large enough to hold all data
		    let initrd_nr++
		    if [ "${CONFIG_IMAGE_LABEL[$i]}" = "$OPTION_DEFAULT" ]; then
			initrd_default=$initrd_nr
		    fi
		    initrd_copy[$initrd_nr]="$image"
		    CONFIG_IMAGE_INITRD[$i]=$(printf "initrd.%03d\n" $initrd_nr)
		fi
	    fi

	    echo "image = ${CONFIG_IMAGE_FILE[$i]}"
	    test -z "${CONFIG_IMAGE_LABEL[$i]}"  || echo "    label = ${CONFIG_IMAGE_LABEL[$i]}"
	    test -z "${CONFIG_IMAGE_ROOT[$i]}"   || echo "    root = ${CONFIG_IMAGE_ROOT[$i]}"
	    test -z "${CONFIG_IMAGE_APPEND[$i]}" || echo "    append = \"${CONFIG_IMAGE_APPEND[$i]}\""
	    test -z "${CONFIG_IMAGE_SYSMAP[$i]}" || echo "    sysmap = ${CONFIG_IMAGE_SYSMAP[$i]}"
	    test -z "${CONFIG_IMAGE_INITRD[$i]}" || echo "    initrd = ${CONFIG_IMAGE_INITRD[$i]}"
	done
    } > $TEMP/yaboot.conf

    #echo RESULT:
    #cat 	$TEMP/yaboot.conf
    #echo
    #echo press return to continue
    #read

    local device=${OPTION_BOOT%%+([0-9])}	 # split boot option to
    local -i partition=${OPTION_BOOT##+([^0-9])} # dev & part for parted

    if (( partition == 0 )); then
	error "please specify the boot partition NUMBER in boot= $OPTION_BOOT"
    fi

    # read specifications for primary partitions from boot device

    # parse and output like the following
    #
    #	  parted /dev/sda print
    #     Disk geometry for /dev/sda: 0.000-70006.835 megabytes
    #	   ....
    #	  Minor    Start       End     Type      Filesystem  Flags
    #	  1          0.016     22.000  primary               type=41
    #	  2         22.000   1048.000  primary   linux-swap  type=82
    #	  3       1048.000   5146.000  primary   reiserfs    type=83
    #	  4       6000.000  70006.000  extended              lba, type=0f
    #	   ....
    #
    local -a p_start p_end p_type p_flags

    while read; do
	local minor start end type fs_n_flags

	[[ "${REPLY:0:1}" == [1234D] ]] || continue
	read  minor start end type fs_n_flags <<< "$REPLY"
	(( minor > 4 )) && continue
	case $minor in
	    1|2|3|4)
		p_start[$minor]=${start/.}
		p_end[$minor]=${end/.}
		p_type[$minor]=${type}
		p_flags[$minor]=${fs_n_flags}
		;;
	    Disk)
		REPLY=${REPLY#Disk geometry*-}
		REPLY=${REPLY% megabytes*}
		p_start[5]=${REPLY/.}
		;;
	    *)
	        error "unparsable line on parted output: $REPLY"
		;;
	esac
    done < <( $PARTED $device print )

    if (( vmlinux_nr + initrd_nr > 0 )); then
	# copy all kernels and initrds from non supported file systems
	# to one FAT partition

	# check size of partition OPTION_BOOT, must fit at least the default kernel
	local -i bootsize=$(( (p_end[partition]-p_start[partition])*2 ))	# size in blocks
	
	# check if default image/initrd fits, add overhead of 180 blocks approx.
	local -i defaultsize=$(( 180 + $(fsize /lib/lilo/chrp/yaboot.fat) + $(fsize $TEMP/yaboot.conf) ));
	(( defaultsize += (vmlinux_default==0) ? 0 : $(fsize ${vmlinux_copy[$vmlinux_default]}) ));
	(( defaultsize += (initrd_default==0) ? 0 : $(fsize ${initrd_copy[$initrd_default]}) ));

	if (( bootsize < defaultsize )); then
	    # may be resize of the partition is possible and helps?
	    if (( (p_start[partition+1]-p_start[partition])*2  < defaultsize )); then
		error "Boot partition '$OPTION_BOOT' cannot hold $defaultsize blocks"
	    fi
	    echo >&2 "Warning: Extending boot partition $OPTION_BOOT, using free disk space"
	    local start=$(div1000 ${p_start[$partition]})
	    local end=$(div1000 ${p_start[$((partition+1))]} )
	    if ! { $PARTED $device rm $partition &&
		$PARTED $device mkpart primary $start $end &&
		$PARTED $device set $partition type 6; } >& /dev/null
	      then
		  error "Partition extension failed for $OPTION_BOOT"  
	    fi
	fi

	# make it error friendly (tm) and try to unmount boot partition
	[[ "$(</proc/mounts)" == *$OPTION_BOOT\ * ]] && umount $OPTION_BOOT

	# create the FAT partition and file system on $OPTION_BOOT
	if [[ "${fat_part[*]} " != *$OPTION_BOOT\ * ]]; then
	    # set type to be FAT16
	    echo >&2 "Warning: Boot partition $OPTION_BOOT converted to FAT16 type"
	    if ! $PARTED $device set $partition type 6 >& /dev/null; then
		error "Partition conversion failed for $OPTION_BOOT"
	    fi
	fi
	mkfs.msdos -s 8 $OPTION_BOOT || exit 2
	cd $TEMP
	mkdir -p boot || exit 2
	mount $OPTION_BOOT boot || exit 2
	cp -v /lib/lilo/chrp/yaboot.fat boot/yaboot || exit 2
	cp -v $TEMP/yaboot.conf boot/yaboot.cnf || exit 2

	# copy default image
	if (( vmlinux_default != 0 )); then
	    cp -v ${vmlinux_copy[$vmlinux_default]} \
	      boot/vmlinux.$(printf "%03d" $vmlinux_default) || exit 2
	    unset vmlinux_copy[$vmlinux_default]
	fi
	if (( initrd_default != 0 )); then
	    cp -v ${initrd_copy[$initrd_default]} \
	      boot/initrd.$(printf "%03d" $initrd_default) || exit 2
	    unset initrd_copy[$initrd_default]
	fi

	# copy all images except the default ...
	for (( i=1; i<=vmlinux_nr; i++ )); do
	    local f="${vmlinux_copy[$i]}"
	    if [ "$f" ]; then
		cp -v $f boot/vmlinux.$(printf "%03d" $i) || exit 2
	    fi
	done
	for (( i=1; i<=initrd_nr; i++ )); do
	    local f="${initrd_copy[$i]}"
	    if [ "$f" ]; then
		cp -v $f boot/initrd.$(printf "%03d" $i) || exit 2
	    fi
	done

	mkdir boot/ppc
	# create a bootinfo object to make OF happy
	{
	    echo "<chrp-boot>"
	    echo "    <description>SUSE SLES-9 (PPC)</description>"
	    echo "    <os-name>SUSE SLES-9 (PPC)</os-name>"
	    echo "    <boot-script>"
	    echo "        boot &device;:$partition,yaboot"
	    echo "    </boot-script>"
	    echo "</chrp-boot>"
	} > boot/ppc/bootinfo.txt
	mkdir boot/ppc/chrp
	umount boot
    else
	# check for PReP partition and convert $OPTION_BOOT if neseccary
	if [[ "${prep_part[*]} " != *$OPTION_BOOT\ * ]]; then
	    # set type to be PReP boot
	    echo >&2 "Warning: Boot partition $OPTION_BOOT converted to PReP boot type"
	    if ! $PARTED $device set $partition type 0x41 >& /dev/null; then
		error "Partition conversion failed for $OPTION_BOOT"
	    fi
	fi

	# shrink PReP boot partition if bigger than 4MB
	if (( (p_end[partition]-p_start[partition]) > 4000 )); then
	    echo >&2 "Warning: Shrinking PReP boot partition $OPTION_BOOT, avoiding firmware confusion"
	    local start=$(div1000 ${p_start[$partition]})
	    local end=$(div1000 $(( p_start[partition] + $(fsize /lib/lilo/chrp/yaboot.chrp) )) ) 
	    if ! { $PARTED $device rm $partition &&
		$PARTED $device mkpart primary $start $end &&
		$PARTED $device set $partition type 0x41; } >& /dev/null
	    then
		error "Partition shrink failed for $OPTION_BOOT"  
	    fi
	fi

	echo Installing /lib/lilo/chrp/yaboot.chrp onto $OPTION_BOOT
	dd if=/lib/lilo/chrp/yaboot.chrp of=$OPTION_BOOT 2>/dev/null
	cp $TEMP/yaboot.conf /etc/yaboot.conf || exit 2
	echo "Converted /etc/lilo.conf to /etc/yaboot.conf"
    fi

    # TODO check whether this is neccessary
    if [[ ${p_flags[$partition]} != *boot* ]]; then
	$PARTED $device set $partition boot on >& /dev/null
    fi

    NV_BOOT_PATH=$(get_of_path $OPTION_BOOT)
    if (( vmlinux_nr + initrd_nr > 0 )); then
	nvsetenv bootinfo-linux "${NV_BOOT_PATH},\ppc\bootinfo.txt"
	NV_BOOT_PATH=${NV_BOOT_PATH},yaboot
    else
	NV_BOOT_PATH=${NV_BOOT_PATH%:+([0-9])}
    fi

    if [ "$OPTION_ACTIVATE" = "yes" ] ; then
	echo "setting open firmware variable boot-device to '$NV_BOOT_PATH'"
	nvsetenv boot-device "$NV_BOOT_PATH"
	if [ "$(nvsetenv boot-file)" != "boot-file=" ]; then
	    echo "old boot-file (contains addition OF boot args for kernel, but breaks yaboot):"
	    nvsetenv boot-file
	    nvsetenv boot-file ""
	fi
    else
	echo "boot path not set to boot linux as requested"
	echo "please add '$NV_BOOT_PATH' somewhere to your boot path manually"
    fi
}


function running_on_iseries () {
    echo running on iSeries
    ISERIES_KERNEL_TMPFILE=$TEMP/vmlinux.initrd
    
    if [ ! -z "$OPTION_DEFAULT" ] ; then
	# find the default= line
	for ((i=1; i<=CONFIG_IMAGE_COUNT; i++)); do
	    if [ "$OPTION_DEFAULT" =  "${CONFIG_IMAGE_LABEL[$i]}" ] ; then
		ISERIES_IMAGE="${CONFIG_IMAGE_FILE[$i]}" 
		if [ -n "$OPTION_APPEND" ] ; then
		    ISERIES_CMDLINE=$OPTION_APPEND
		fi
		if [ -n "${CONFIG_IMAGE_APPEND[$i]}" ] ; then
		    ISERIES_CMDLINE=${CONFIG_IMAGE_APPEND[$i]}
		fi
		if [ -n "$OPTION_ROOT" ] ; then
		    ISERIES_ROOT="root=$OPTION_ROOT"
		fi
		if [ -n "${CONFIG_IMAGE_ROOT[$i]}" ] ; then
		    ISERIES_ROOT="root=${CONFIG_IMAGE_ROOT[$i]}"
		fi
		if [ -n "$OPTION_INITRD" ] ; then
		    ISERIES_INITRD=$OPTION_INITRD
		fi
		if [ -n "${CONFIG_IMAGE_INITRD[$i]}" ] ; then
		    ISERIES_INITRD="${CONFIG_IMAGE_INITRD[$i]}"
		fi
	    fi
	done
    else
	# pick the first image= line
	ISERIES_IMAGE="${CONFIG_IMAGE_FILE[1]}"
	if [ -n "$OPTION_APPEND" ] ; then
	    ISERIES_CMDLINE=$OPTION_APPEND
	fi
	if [ -n "${CONFIG_IMAGE_APPEND[1]}" ] ; then
	    ISERIES_CMDLINE=${CONFIG_IMAGE_APPEND[1]}
	fi
	if [ -n "$OPTION_ROOT" ] ; then
	    ISERIES_ROOT="root=$OPTION_ROOT"
	fi
	if [ -n "${CONFIG_IMAGE_ROOT[1]}" ] ; then
	    ISERIES_ROOT="root=${CONFIG_IMAGE_ROOT[1]}"
	fi
	if [ -n "$OPTION_INITRD" ] ; then
	    ISERIES_INITRD=$OPTION_INITRD
	fi
	if [ -n "${CONFIG_IMAGE_INITRD[1]}" ] ; then
	    ISERIES_INITRD="${CONFIG_IMAGE_INITRD[1]}"
	fi
    fi
    
    #
    #  loop for multiple OPTION_BOOT entries
    #
    for (( i=0; i<OPTION_BOOT_COUNT; i++ )); do
	ISERIES_BOOT="${OPTION_BOOT[$i]##*=}"
	ISERIES_DEVICE="${OPTION_DEVICE[$i]}" 
	ISERIES_BOOT_IMAGE="$ISERIES_IMAGE"

	echo "ISERIES_CMDLINE " $ISERIES_CMDLINE
	echo "ISERIES_ROOT    " $ISERIES_ROOT
	echo "ISERIES_IMAGE   " $ISERIES_IMAGE
	echo "ISERIES_BOOT    " $ISERIES_BOOT

	if [ -n "$ISERIES_INITRD" ]; then
	    echo "ISERIES_INITRD  " $ISERIES_INITRD
	    echo
	    echo generating $ISERIES_KERNEL_TMPFILE with /lib/lilo/iseries/make_zimage_iseries.sh
	    echo
	    unset ec
	    /lib/lilo/iseries/make_zimage_iseries.sh \
	      --initrd $ISERIES_INITRD \
	      --vmlinux $ISERIES_IMAGE \
	      --output $ISERIES_KERNEL_TMPFILE ; ec=$?
	    echo
	    if [ "$ec" != "0" ]; then
		echo bootfile generation failed: ec $ec ;
		exit 1 ;
	    fi
	    ISERIES_BOOT_IMAGE=$ISERIES_KERNEL_TMPFILE
	fi
	echo ISERIES_BOOT_IMAGE $ISERIES_BOOT_IMAGE
	unset ISERIES_TARGET
	if [[ "$ISERIES_BOOT" == [AB] ]]; then
	    ISERIES_TARGET=slot
	elif [ -c "$ISERIES_BOOT" -o -d "$ISERIES_BOOT" -o -p "$ISERIES_BOOT" -o -S "$ISERIES_BOOT" ]; then
	    ISERIES_TARGET=invalid
	elif [ -b "$ISERIES_BOOT" ]; then
	    ISERIES_TARGET=block_dev
	elif [ -f "$ISERIES_BOOT" -o ! -e "$ISERIES_BOOT" ]; then
	    ISERIES_TARGET=file
	else
	    ISERIES_TARGET=invalid
	fi
    
	case "$ISERIES_TARGET" in
	  slot)
		echo write to slot $ISERIES_BOOT
		;;
	  file)
		if [ "${ISERIES_BOOT:0:1}" != "/" ] ; then
		    echo boot=$ISERIES_BOOT must have an absolute path
		    case "$ISERIES_BOOT" in
		      a|b|c)
			     echo "Did you mean uppercase '$ISERIES_BOOT'?"
			     ;;
		    esac
		    exit 1
		fi
		echo write to file $ISERIES_BOOT
		rm -f $ISERIES_BOOT
		cp -a $ISERIES_BOOT_IMAGE $ISERIES_BOOT
		;;
	  block_dev)
		     echo write to block_dev "$ISERIES_BOOT"
		     ;;
	  invalid)
		   echo "Error: boot=$ISERIES_BOOT invalid"
		   exit 1
		   ;;
	esac
	
	if [ "$ISERIES_TARGET" = "slot" -a -n "$ISERIES_BOOT_IMAGE" -a -f "$ISERIES_BOOT_IMAGE" ] ; then
	    local size name bs=1024 target=/proc/iSeries/mf/$ISERIES_BOOT/vmlinux

	    read size name < <(ls -Ls --block-size=1024 $ISERIES_BOOT_IMAGE)
	    echo "this will take a while... ($size kb)"
	    echo "writing kernel $ISERIES_BOOT_IMAGE to $target"

	    while ! dd if=$ISERIES_BOOT_IMAGE of=$target bs=${bs}k 2>/dev/null ; do
		# try smaller chunk size in case of error (ENOMEM)
		(( bs >>= 1 ));
		if (( bs < 4 )); then
		    # bail out below 4kB
		    echo "failed to write kernel to slot $ISERIES_BOOT"
		    exit 1
		fi
	    done
		
	    echo activate kernel slot $ISERIES_BOOT in /proc/iSeries/mf/side
	    echo $ISERIES_BOOT > /proc/iSeries/mf/side
	        
	    # remove any old cmdline content, leads to newlines
	    dd if=/dev/zero of=/proc/iSeries/mf/$ISERIES_BOOT/cmdline count=1 bs=254 2>/dev/null
	    echo "$ISERIES_ROOT $ISERIES_CMDLINE" > /proc/iSeries/mf/$ISERIES_BOOT/cmdline
	fi
    
    
	if [ "$ISERIES_TARGET" = "block_dev" ]; then
	    #only the device is given and dd to the raw device is a bad idea
	    if [ -z "${OPTION_PARTITION[$i]}" ]; then
		echo guess the prep boot device 
		PART=`$FDISK -l $ISERIES_DEVICE | fgrep "PPC PReP"`
		if [ -z "$PART" ] ; then
		    error "config error, boot = $ISERIES_BOOT is not 41 PReP" 3
		fi
		if [ `echo "$PART" | wc -l` != 1 ] ; then
		    err_var1="$ISERIES_BOOT"
		    error "config error, guessing of boot partition failed" 5
		fi
		read P dummy <<< "$PART"
	    else
		#we have the device, but better safe than sorry
		echo Boot target is $ISERIES_DEVICE
		PART=`$FDISK -l $ISERIES_DEVICE | grep $ISERIES_BOOT | fgrep "PPC PReP"`
		if [ -z "$PART" ] ; then
		    error "config error, boot = $ISERIES_BOOT is not 41 PReP" 3
		fi
		
		P=$ISERIES_BOOT
	    fi
		
	    echo Installing "$ISERIES_BOOT_IMAGE" onto $P
	    dd if="$ISERIES_BOOT_IMAGE" of=$P bs=4096 2>/dev/null
		
	    echo setting boot flag on partition ${P%%+([0-9])} ${P##+([^0-9])}
	    $PARTED ${P%%+([0-9])} set ${P##+([^0-9])} boot on >& /dev/null
	fi
    done  #  end of OPTION_BOOT loop

    if [ "$OPTION_ACTIVATE" = "yes" ] ; then
	echo "To activate your partition you have to change your NWSD manually"
	# TODO print nice proposals for OS400 cmds
	#
	#  loop for multiple OPTION_BOOT entries
	#
	#for (( i=0; i<OPTION_BOOT_COUNT; i++ )); do

	# echo "    CHGNWSD <nwsd-name> ......."

	# done
    fi
}


function running_on_prep () {
    echo running on prep
    #only the device is given and dd to the raw device is a bad idea
    
    if [ -z "$OPTION_PARTITION" ] ; then
	echo guess the prep boot device 
	PART=`$FDISK -l $OPTION_DEVICE | fgrep "PPC PReP"`
	if [ -z "$PART" ] ; then
	    error "config error, boot = $OPTION_BOOT is not 41 PReP" 4
	fi
	if [ `echo "$PART" | wc -l` != 1 ] ; then
	    err_var1="$OPTION_BOOT"
	    error 'config error, guessing of boot partition failed' 5
	fi
	read P dummy <<< "$PART"
    else
	#we have the device, but better safe than sorry
	echo Boot target is $OPTION_DEVICE
	PART=`$FDISK -l $OPTION_DEVICE | grep $OPTION_BOOT | fgrep "PPC PReP"`
	if [ -z "$PART" ] ; then
	    error "config error, boot = $OPTION_BOOT is not 41 PReP" 4
	fi

	P=$OPTION_BOOT
    fi
    PREP_IMAGE=
    PREP_CMDLINE=
    PREP_INITRD=
    if [ ! -z "$OPTION_DEFAULT" ] ; then
	# find the default= line
	for ((i=1; i<=CONFIG_IMAGE_COUNT; i++)); do
	    if [ "$OPTION_DEFAULT" =  "${CONFIG_IMAGE_LABEL[$i]}" ] ; then
		PREP_IMAGE="${CONFIG_IMAGE_FILE[$i]}" 
		if [ -n "$OPTION_APPEND" ] ; then
		    PREP_CMDLINE=$OPTION_APPEND
		fi
		if [ -n "${CONFIG_IMAGE_APPEND[$i]}" ] ; then
		    PREP_CMDLINE=${CONFIG_IMAGE_APPEND[$i]}
		fi
		if [ -n "$OPTION_ROOT" ] ; then
		    PREP_CMDLINE="root=$OPTION_ROOT $PREP_CMDLINE"
		fi
		if [ -n "${CONFIG_IMAGE_ROOT[$i]}" ] ; then
		    PREP_CMDLINE="root=${CONFIG_IMAGE_ROOT[$i]} $PREP_CMDLINE"
		fi
		if [ -n "$OPTION_INITRD" ] ; then
		    PREP_INITRD=$OPTION_INITRD
		fi
		if [ -n "${CONFIG_IMAGE_INITRD[$i]}" ] ; then
		    PREP_INITRD="${CONFIG_IMAGE_INITRD[$i]}"
		fi
	    fi
	done
    else
	# pick the first image= line
	PREP_IMAGE="${CONFIG_IMAGE_FILE[1]}"
	if [ -n "$OPTION_APPEND" ] ; then
	    PREP_CMDLINE=$OPTION_APPEND
	fi
	if [ -n "${CONFIG_IMAGE_APPEND[1]}" ] ; then
	    PREP_CMDLINE=${CONFIG_IMAGE_APPEND[1]}
	fi
	if [ -n "$OPTION_ROOT" ] ; then
	    PREP_CMDLINE="root=$OPTION_ROOT $PREP_CMDLINE"
	fi
	if [ -n "${CONFIG_IMAGE_ROOT[1]}" ] ; then
	    PREP_CMDLINE="root=${CONFIG_IMAGE_ROOT[1]} $PREP_CMDLINE"
	fi
	if [ -n "$OPTION_INITRD" ] ; then
	    PREP_INITRD=$OPTION_INITRD
	fi
	if [ -n "${CONFIG_IMAGE_INITRD[1]}" ] ; then
	    PREP_INITRD="${CONFIG_IMAGE_INITRD[1]}"
	fi
    fi
    if [ ! -z "$PREP_INITRD" ] ; then
	PREP_INITRD="--initrd $PREP_INITRD"
    fi
    /lib/lilo/prep/make_zimage_prep.sh \
    --vmlinux "$PREP_IMAGE" \
    $PREP_INITRD \
    --tmp "$TEMP" \
    --output "$TEMP/zImage.prep"
    /lib/lilo/chrp/mkzimage_cmdline \
    	-a 1 \
	-s "$PREP_CMDLINE" \
	"$TEMP/zImage.prep"
    echo "Installing $TEMP/zImage.prep onto $P"
    dd if="$TEMP/zImage.prep" of=$P 2>/dev/null
}


function running_on_pmac_old () {
    source /lib/lilo/lilo-pmac.lib
    running_on_pmac_old;
}


function running_on_pmac_new () {
    source /lib/lilo/lilo-pmac.lib
    running_on_pmac_new;
}


function real_device () {
    # print the real device i.e. map partitions to disks
    local -i dev=$1 real=0
    local -i major minor
    local range
    local IFS=:

    # assert that /sys is mounted, else try to mount,
    # on fail fall back to error value
    if test -d /sys/block || mount -t sysfs sysfs /sys; then
	# that and check whether the integer 
	while read range; do
	    read major minor < ${range/range/dev}
	    (( real = major * 256 + minor ))
	    range=$(<$range)
	    if (( dev >= real && dev < real + range )); then
		echo $real
		return;
	    fi
	done < <( find /sys/block -name range )
    fi
    echo 0000
}


function device_of_file () {
    # print device number in decimal given a file path
    local f="$1";
    
    if [ ! -x $STAT_CMD -o -z "$f" ]; then
	# be nice if /usr not mounted
	echo 0000
	return;
    fi
    
    $STAT_CMD --format="%d" $f
}

       
function device_nr () {
    # print device number in decimal given a path to a device node
    local d="$1"
    
    # /dev/root is an alias to the root file system
    if [ "$d" == "/dev/root" ]; then
	device_of_file /
	return;
    fi

    if [ ! -x $STAT_CMD ]; then
	# be nice if /usr not mounted
	echo 0000
	return;
    fi

    # test whether its a block device ?
    if [ ! -b "$d" ]; then
	# this should never happen
	echo >&2 "Path '$d' does not point to a block device node!"
	echo 0000
	return;
    fi

    echo $[ $($STAT_CMD --format "0x%t*256 + 0x%T" $d) ]
}


function check_arch () {
    # check for the current ppc subarch
    unset COPY_BOOT_FILES
    while read line; do
	case "$line" in
	  #		dont force copy on new macs until yaboot is fixed
	  #		*MacRISC2*)	MACHINE="pmac" ; COPY_BOOT_FILES="true" ;;
	  *MacRISC*)	MACHINE="pmac" ;;
	  *CHRP*)	MACHINE="chrp" ;;
	  *PReP*)	MACHINE="prep" ;;
	  *iSeries*)	MACHINE="iseries" ;;
	esac
    done < /proc/cpuinfo
    
    if [ "$MACHINE" = "pmac" ] ; then
	if [ -f /proc/device-tree/openprom*/model ] ; then
	    echo `cat /proc/device-tree/openprom*/model` > $TEMP/openprom_model
	    while read openfirmware ofversion; do
		case "$openfirmware" in
		  iMac,1|OpenFirmware)	MACHINE="pmac_new" ;;
		  Open) 		MACHINE="pmac_old" ;;
		esac
	    done < $TEMP/openprom_model
	fi
    fi
} #end function check_arch


function parse_config_file () {
    # parse the lilo.conf and place it in CONFIG_IMAGE_FILE[]
    # other vars:
    # OPTION_BOOT is an array to contains the bootloader partition and/or targets
    # OPTION_BOOT_COUNT is a counter to the array above
    # OPTION_OTHER contains the MacOS partition
    # OPTION_BOOTFOLDER contains the MacOS folder with the bootstuff
    # OPTION_ACTIVATE is a flag whether or not the boot partition must be set active in OF
    # OPTION_TIMEOUT contains the timeout variable in seconds
    # OPTION_DEFAULT contains the default label
    # OPTION_ROOT contains the global or local root= device
    # OPTION_APPEND contains the global or local append= strings
    # OPTION_INITRD containes the global or local initrd filename
    # OPTION_IMAGE_COPY contains a flag to force copy to the boot partition
    # internal vars:
    # CONFIG_PARSE_HASIMAGE is a flag if we have a image section.
    # CONFIG_IMAGE_FILE contains the kernel image for a section
    # CONFIG_IMAGE_OTHER contains the device of MacOS
    # CONFIG_IMAGE_COUNT is a simple counter of image sections
    declare option
    local separator value

    unset CONFIG_PARSE_HASIMAGE
    CONFIG_IMAGE_COUNT=0
    OPTION_BOOT_COUNT=0
    while read; do
	# strip comments, heading and trailing whitespace and empty lines
	REPLY=${REPLY%%#*}
	REPLY=${REPLY%%+([ 	])}
	REPLY=${REPLY##+([ 	])}
	if [ -z "$REPLY" ]; then continue; fi
	REPLY=${REPLY/=/ = }
	REPLY=${REPLY/\"\"/}	# replace quoted empty string by "itself"
 
	read option separator value <<< "$REPLY"
	#	echo option "$option"
	#	echo separator "$separator"
	#	echo value $value

	if [ -n "$separator" ] && [ "$separator" != "=" ]; then
	    echo "Illegal separator '$separator', line ignored"
	    continue
	fi

	case "$option" in
	    boot)
		[ "$CONFIG_PARSE_HASIMAGE" ] && error 7
		OPTION_BOOT[$OPTION_BOOT_COUNT]=$value
		let OPTION_BOOT_COUNT++
		;;
	    activate)
		[ "$CONFIG_PARSE_HASIMAGE" ] && error 7
		OPTION_ACTIVATE="yes"
		;;
	    progressbar)
		# do nothing
		;;
	    bootfolder)
		[ "$CONFIG_PARSE_HASIMAGE" ] && error 7
		OPTION_BOOTFOLDER=":${value}"
		;;
  	    timeout)
		[ "$CONFIG_PARSE_HASIMAGE" ] && error 7
		OPTION_TIMEOUT=$value
		;;
	    default)
		[ "$CONFIG_PARSE_HASIMAGE" ] && error 7
		OPTION_DEFAULT=$value
		;;
	    image)
		# check if previous image section has a label
		if [ "$CONFIG_PARSE_HASIMAGE" ] ; then
		    err_var1="${CONFIG_IMAGE_FILE[$CONFIG_IMAGE_COUNT]:-${CONFIG_IMAGE_OTHER[$CONFIG_IMAGE_COUNT]}}"
		    if [ -z "$err_var1" ]; then	error 6; fi
		fi
		CONFIG_PARSE_HASIMAGE=true
		let CONFIG_IMAGE_COUNT++
		CONFIG_IMAGE_FILE[$CONFIG_IMAGE_COUNT]=$value
		;;
	    other)
		# check if previous image section has a label
		if [ "$CONFIG_PARSE_HASIMAGE" ] ; then
		    err_var1="${CONFIG_IMAGE_FILE[$CONFIG_IMAGE_COUNT]:-${CONFIG_IMAGE_OTHER[$CONFIG_IMAGE_COUNT]}}"
		    if [ -z "$err_var1" ]; then	error 6; fi
		fi
		CONFIG_PARSE_HASIMAGE=true
		CONFIG_PARSE_HASOTHER=true
		let CONFIG_IMAGE_COUNT++
		CONFIG_IMAGE_OTHER[$CONFIG_IMAGE_COUNT]=$value
		OPTION_OTHER=$value
		;;
	    root)
		if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		    OPTION_ROOT=$value
		else
		    CONFIG_IMAGE_ROOT[$CONFIG_IMAGE_COUNT]=$value
		fi
		;;
	    copy)
		[ "$CONFIG_PARSE_HASIMAGE" ] || error 8
		CONFIG_IMAGE_COPY[$CONFIG_IMAGE_COUNT]="true"
		;;
	    label)
		[ "$CONFIG_PARSE_HASIMAGE" ] || error 8
		CONFIG_IMAGE_LABEL[$CONFIG_IMAGE_COUNT]=$value
		;;
	    append)
		if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		    # use eval to strip ""
		    eval OPTION_APPEND=$value
		else
		    # use eval to strip ""
		    eval CONFIG_IMAGE_APPEND[$CONFIG_IMAGE_COUNT]=$value
		fi
		;;
	    sysmap)
		[ "$CONFIG_PARSE_HASIMAGE" ] || error 8
		CONFIG_IMAGE_SYSMAP[$CONFIG_IMAGE_COUNT]=$value
		;;
	    initrd)
		if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
		    OPTION_INITRD=$value
		else
		    CONFIG_IMAGE_INITRD[$CONFIG_IMAGE_COUNT]=$value
		fi
		;;		
	    *)
	        error "!!!!!!!!!! unkown option $option !!!!!!!!!!!!!"
		;;
	esac
    done < $CONFIG_LILO_CONF
    
} #end function parse_config_file


function check_config_file () {
    if [ -z $OPTION_BOOT ]; then
	#   work around a YaST bug, which comes from a certain kind of
	#   intel-architecture blindness, some architectures can guess boot
	#   drive :-)
	if [[ "$MACHINE" != @(chrp|prep) ]]; then
	    error "boot= is not specified!"
	fi
    else
	if [ "$MACHINE" != "iseries" ]; then
	    if [ ! -b $OPTION_BOOT ]; then
		error "boot = $OPTION_BOOT is not a valid block device"
	    fi
	    if [ $OPTION_BOOT_COUNT -ne 1 ]; then
		errot "only one boot= line allowed here!"
	    fi
	fi
    fi
    if [ -z "$CONFIG_PARSE_HASIMAGE" ] ; then
	error "no image section is specified"
    fi
    
    for (( i=1; i<=CONFIG_IMAGE_COUNT; i++ )); do
	if [ ! -f ${CONFIG_IMAGE_FILE[$i]} ] ; then
	    error "image = ${CONFIG_IMAGE_FILE[$i]} ist not a regular file"
	fi
	if [ ! -f ${CONFIG_IMAGE_INITRD[$i]} ] ; then
	    error "initrd = ${CONFIG_IMAGE_INITRD[$i]} ist not a regular file"
	fi
	if [ ! -f ${CONFIG_IMAGE_SYSMAP[$i]} ] ; then
	    error "sysmap = ${CONFIG_IMAGE_SYSMAP[$i]} ist not a regular file"
	fi
    done
    
    #
    #  loop for multiple OPTION_BOOT entries
    #
    for (( i=0; i<OPTION_BOOT_COUNT; i++ )); do
	OPTION_DEVICE[$i]="${OPTION_BOOT[$i]%%+([0-9])}"	 # split boot option to
	OPTION_PARTITION[$i]="${OPTION_BOOT[$i]##+([^0-9])}"	 # dev & part for parted
    done
} #end function check_config_file


function fsize() { # get file size in blocks
    local s f r
    if [ -z "$1" ]; then
	echo 0
    else
	read s f r < <(ls -Ls --block-size=512 $1)
	echo $s
    fi
}


function prepare_environment () {
    rm -rf $TEMP
    mkdir -p $TEMP
    trap "clean_environment" EXIT INT
} #end function prepare_environment


function clean_environment () {
    [[ $(</proc/mounts) == *$TEMP/boot\ * ]] && umount $TEMP/boot
    rm -rf $TEMP
} #end function clean_environment

#
# here we go
#

prepare_environment
check_arch
parse_config_file
check_config_file

case "$MACHINE" in
    pmac_new)  running_on_pmac_new ;;
    pmac_old)  running_on_pmac_old ;;
    chrp)      running_on_chrp     ;;
    prep)      running_on_prep     ;;
    iseries)   running_on_iseries  ;;
esac

#
#for i in `seq 1 $CONFIG_IMAGE_COUNT`;do
#	echo section $i:
#	echo image  ${CONFIG_IMAGE_FILE[$i]}
#	echo label  ${CONFIG_IMAGE_LABEL[$i]}
#	echo append ${CONFIG_IMAGE_APPEND[$i]}
#	echo initrd ${CONFIG_IMAGE_INITRD[$i]}
#	echo root   ${CONFIG_IMAGE_ROOT[$i]}
#done
#
# set | less

#
#
# Local variables:
#     mode: ksh
#     mode: font-lock
#     mode: auto-fill
#     ksh-indent: 4
#     ksh-multiline-offset: 2
#     ksh-if-re: "\\s *\\b\\(if\\)\\b[^=]"
#     fill-column: 78
# End:
#
